
_____________________________________________
Урок 28 'Методы и свойства строк и чисел'

Методы - это вспомогательные функции.
Свойства - это вспомогательные значения.

**Методы СТРОК:****************************************************************************************************
(https://learn.javascript.ru/string)
Документация (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String)


let frut = 'hi my name ';

1) .indexOf('..'); - ищет буквы/слова в строке frut

2) .slice(5, 11) - вырезает фрагмент в строке с 5 символа по 11 символ. Если аргумент только один, то вырезаем с этого символа и до конца строки

3) .substring(5, 11) - тоже самое , что и .slice (есть небольшие особенности)

4) .substr(5 , 3) - вырезает фрагмент в строке с пятого символа , длиной 3 символа

5) .trim() - убирает пробелы в строке (использовать, чтобы не вводили просто пробелы)

6) .charAt(1) - получаем 2 символ в строке

7) .toUpperCase() - делает буквы заглавными 

8) .toLowerCase() - делает буквы строчными 

9) Str.includes(x) - определяет, содержит ли строка определённый элемент, возвращая в зависимости от этого true или false

10) str.match() - возвращает получившиеся совпадения при сопоставлении строки с регулярным выражением
Возвращает массив, содержащий результаты сопоставления или null, если ничего не было сопоставлено.

11) str.replace(x, y) - возвращает новую строку с некоторым[^a-z-]и или всеми сопоставлениями с шаблоном, заменёнными на заменитель.
					x - что заменяем; y - на что заменяем

12) str.charCodeAt(index) - возвращает числовое значение Юникода для символа по указанному индексу

13) str.repeat(count) - конструирует и возвращает новую строку, содержащую указанное количество соединённых вместе копий строки, на которой он был вызван.
					count - количество повторений 



**Методы ЧИСЕЛ:*******************************************************************************************************
(https://learn.javascript.ru/number) 
Документация (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number)


let num = 543.12;

Math.round(num) - округляет до ближайшего целого


**Математические функции :********************************************************************************************
Документация (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math)


let num = 543.12;

1) Math.ceil(num) - округляет в бОльшую сторону

2) Math.round(num) - округляет до ближайшего целого

3) Math.floor() - округляет в меньшую сторону

4) Math.max() - возвращает наибольшее значение 

5) Math.min() - возвращает наименьшее значение 

6) num.toString(radix) - radix Необязательный параметр. Целое число между 2 и 36, определяющее основание системы счисления, 
используемой для представления числового значения.




****** Методы обьектов******************************************************************************************

1) Перебрать обьект for ... in obj  - перебирает каждый элемент обьекта  
	for (let key in obj){
		console.log(key);
	}

2) Object.keys(obj).length; - выводит массив со всеми ключами обьекта и считает длину обьекта(то есть массива)

3) const copy = Object.assign({}, data); - копирует все свойства из одного обьекта или нескольких (data) в другой({}) и возвращает его

4) Object.values(obj) - Метод возвращает массив значений перечисляемых свойств объекта в том же порядке что и цикл for...in. Разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов.

5) delete Obj.class; - удаляет свойство обьекта 

6) Object.entries(obj) - возвращает массив(массив массивов) собственных перечисляемых свойств указанного объекта в формате [key, value]

7) Object.fromEntries() - из массива с массивами создает объект ( из map в object)

8) Object.fromEntries(obj) - преобразует массив [key, value] в объект {key: value}

-------------------------- ПРОТИТИПЫ Обьектов (__proto__)-------------------------------------------

6) Object.setPrototypeOf(obj1 , obj2); - установили свойства(прототип) обьекта obj2 , обьекту obj1

7) const obj1 = Object.create(obj2) - создали новый обьект, который будет наследовать свойства у obj2

8) Object.getPrototypeOf(obj1 , obj2) -- &&&&

9) Object.ptototype.exit = function(){} - объекту добавили метод exit с аргументом функции

10) 

11) 



****** Методы массивов*******************************************************************************************************

1) .pop() - удаляет последний элемент и возвращает

2) .push(10) - в конце массива добавляется 10

3) .shift() и .unshift() - удаляет или добавляет и возвращает элемент в/с начале(а) массива, но используется редко, так как долго работает , потому что перезаписывает индексы

4) arr1.concat(arr2. arr3) - объединяет несколько массиивов и возвращает новый массив

5) 

6) .split(", ") - преобразует строку в массив ; ", " - это разделитель 

7) .join("; ") - преобразует массив в строку, "; " - это разделитель 

8) .sort( ) - сортирует элементы внутри массива как строки по алфавиту 

9) delete arr[1] - удаляет 2 элемент массива

10) .splice(index, count, elem1...) - удалить count элементов, начиная с index и заменить на элементы elem1...

11) 

12) .reverse() - меняет порядок элементов на обратный

13) 

14) .find()- позволяет найти в массиве, возвращает первое найденное значение

15) .includes() - позволяет проверить есть ли значение в массиве, возвращает true или false

16) 

17) Object.values(obj) - возвращает массив значений свойств обьекта; obj - наш обьект

18) Array.isArray(obj) - возвращает true , если обьект является массивом

19) 

20) Array.from(arr, func) - создаем массив на основе псевдомассива (getElementsByClassName) или (Set), только он уже становится статичным, а не живым
				~ arr - Массивоподобный или итерируемый объект, преобразуемый в массив. 
				~ func - Отображающая функция, вызываемая для каждого элемента массива.

21) Array.every(callback, index) - проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.

22) Array.indexOf(X) - возвращает первый индекс, по которому данный элемент(X) может быть найден в массиве или -1, если такого индекса нет.

23) Array.includes(x) - определяет, содержит ли строка определённый элемент(X), возвращая в зависимости от этого true или false


********************* Методы перебора массива ***********************************************************************************************************


1) .forEach() - позволяет гибко перебрать, возвращает этот же массив
	arr.forEach(function(item, i , arr){  //item - значение; i - порядковый номер;  arr - массив, который будем переберать(callback функция)
	console.log(`${i}:${item} внутри массива ${arr}`);
	});

2) .filter((item) => {if ... return item}) - создает новый массив со всеми элементами, прошедшими проверку (должны возвращать item)

3) .map((item, i) => {return item.toLowerCase}) - создаёт новый массив с результатом вызова указанной функции для каждого элемента массива. (должны возвращать item)
	item - элемент массива ; i - индекс текущего, обрабатываемого элемента

4) .some(item => typeof(item) === 'number' ) - если хотя бы один item подойдет, то вернет TRUE

5) .every((item, i) => typeof(item) === 'number' ) - если все item массива подходят под условие, то вернет TRUE
        item - элемент массива ; i - индекс текущего, обрабатываемого элемента

6) .reduce((sum, current) => sum + current, some) - применяет функцию к каждому элементу массива. (сворачиваем массив, приводим к одному значению(сумме/строке))
				sum - сумма, current - элемент массива, some - начальное значение(не обязательно)

7) for ... of // Используем когда нужно использовать break или continue
	for (let value of arr){
		console.log(value);
	}




****** ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ *******************************************************************************************************

1) String(5) - преобразовывает число 5 в тип string;

2) Number('привет ') - преобразовывает строку в number

3) +'string' - преобразовывает строку в number (унарный плюс)

4) Boolin(5) - преобразовывает число 5 в тип boolin;


****** Значение False *******************************************************************************************************

1) 0
2) '' - пустая строка
3) null
4) undefined
5) NaN
__________________
Все остальное - это TRUE

 
****** Взаимодействие с элементами страницы DOM *******************************************************************************************************

1) document.querySelectorAll('.css') - все элементы с таким классом (получаем массив) // #id, .class, div, (селекторы)

2) document.querySelector('.css') - первый элемент с таким классом // #id, .class, div, (селекторы)

3) document.getElementById('box') - получаем элемент с id = box 

4) document.getElementsByTagName('button') - получаем элемент по тегу ( получаем псевдомассив) // устаревший

5) document.getElementsByClassName('circle') - получаем элемент по классу ( получаем псевдомассив) // устаревший

5) element.textContent - задает и получает текстовое содержимое элемента; используем когда работаем с текстом

6) element.innerHTML - устанавливает или получает HTML или XML разметку дочерних элементов (.innerHTML = '' - Заменяет содержимое тела пустой строкой.)

7) element.style.backgroundImage = 'url("img/bg.jpg")'; - задавать стили нужным элементам(element.style)

8) .parentElement - обращение к родителю

9) box.style.cssText = 'background-color: blue; width: 500px' - задаем сразу несколько css стилей

10) document.createElement('div') - создали блок div в джава скрипте (на странице он еще не отображается)

11) div.classList.add/remove('black') - добавили блоку div класс black (в css, black уже есть)

12) document.body.append('div') - в body в конец добавили блок div

13) document.body.prepend('div') - в body в начало добавили блок div

14) hearts[0].before(div) - добавили блок div перед первым элементом hearts

15) hearts[0].after(div) - добавили блок div после первого элемента hearts

16) hearts[0].remove - удаляем первый элемент hearts

17) hearts[0].replaceWith(elem[0]) - заменили первый элемент hearts на первый elem

18) element.classList - получаем свойства элементов
	 .classList.length - получаем количество свойств 
	 .classList.item(0) - получаем первый класс элемента
	 .classList.add('red', 'blue') - добавляем класс red , blue
	 .classList.remove('red') - удаляем класс red
	 .classList.toggle('red') - если классred есть у элемента, то удаляем его, если нету то добавляет класс red
	 .classList.contains('red') - если есть данный класс у элемента, возвращает TRUE , если нету - FALSE

19) element.setAttribute('data-atribute', value) - Добавляет новый атрибут или изменяет значение существующего атрибута у выбранного элемента.
                 'data-atribute' - имя атрибута; value - значение атрибута

20) element.insertAdjacentHTML('beforebegin/afterbegin/beforeend/afterend', element ) - вставляет в указанное место element 
______________________________________________

 ****!!!!!   ДЕЛЕГИРОВАНИЕ - https://learn.javascript.ru/event-delegation

вешаем слушатель события не на каждый элемент, а на родителя

с помощью event.target получаем элемент, на котором произошло событие



****** События и их обработчики*******************************************************************************************************
https://oddler.ru/blog/i63 - список событий
https://developer.mozilla.org/ru/docs/Web/API/Event - обьект события


1)** -- elem.onclick =... - при клике будет выполняться то, что напишем - ** лучше не использовать, так как если использовать 2 раза, то запоминаются только 2-е свойства

2) elem.addEventListener('click/mouseenter/ input' , deleteElement) - добавляем элементу слушатель событий / 1- событие, которое слушаем. 2- функция которая будет выполняться
(лучше записывать функцию в переменную const deleteElement = (e) => {e.target.remove()})

3) elem.removeEventListener('click/mouseenter' , deleteElement) - удаляет слушатель событий

4) elem.target -  элемент на котором произошел вызов

5) event.preventDefault(); - прерываем типичные действия , ставится в начало (функции)

6) 



****** События *******************************************************************************************************

1) 'contextmenu' - когда тыкаем правой кнопкой мыши 

2) 'copy' - когда что то копируем 

3) 'cut' - когда что то вырезаем 

4) 'dblclick' - двойной клик 

5) 'resize' - меняем размер окна( вешаем на window) 

6) 'scroll' - реагирует на прокрутку (показывает сколько px мы прокрутили от верха) 

7) 'ended' - срабатывает когда закончилось действие (например закончилось видео) 

8) 'load' - завершилась загрузка страницы (применяют к window.addEventListener('load', ()=>{})) 

9) 'blur' - когда убираем фокус с поля для ввода 

10) 'change' - когда меняем значение (input, select) 

11) 'focus' - когда наш элемент находится в фокусе(когда тыкнули на инпут или наводимся или пишем текс)

12) 'reset' - очищаем элемент на котором происходило действие 

13) 'submit' - когда подтверждаем отправку (например на form    )

14) '' - 

15) '' - 


****** Навигация по DOM - элементам *******************************************************************************************************


1) document.body.childNodes - получаем внутренние узлы элемента body (детей) (получаем массив)

2) document.body.firstChild - получаем первый внутренние узел элемента body (детей)

3) document.body.lastChild - получаем последний внутренние узел элемента body (детей)

4) document.querySelector('#current').parentNode/Element - обращение к родительскому узлу

5) document.querySelector('#current').nextSibling - обращение к следующему узлу

6) document.querySelector('#current').previousSibling - обращение к предыдущему узлу

7) Element.matches('.class') - вернёт true или false, в зависимости от того, соответствует ли элемент указанному css-селектору(class, id, data-atribute и тп).

8) Element.closest('.class') - возвращает ближайший родительский элемент (или сам элемент), который соответствует заданному CSS-селектору или null, если таковых элементов вообще нет.

9)


___________________________________________________________________________________________
Чтобы получить именно элемент нужно добавлять Element вместо Node(в каждом случае по своему)


******Скрипты и атрибуты  *******************************************************************************************************

1) defer - обрабатывается страница и в фоновом режиме загружается скрипт, затем запускается скрипт после того, как DOM дерево будет готово
 (мы не блокируем страницу,скрипты загружаются последовательно)
	<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

2) async - скрипты не зависимы от DOM (кто первый загрузился, тот и начинает сразу работать). 
мы не блокируем страницу, запускаются скрипты по мере загрузки 
**Лучше применять для сторонних скриптов**

	<script async src="https://javascript.info/article/script-async-defer/long.js"></script>


||||||||||||||||______________ДОПОЛНИТЕЛЬНЫЕ ОСНОВЫ JS_________________ |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
------------------------------------------------------------------------------------------------------------------------------------------


******Оператор нулевого слияния  (ES 11) *******************************************************************************************************

Логический оператор сравнения(частный случай || *или).

Оператор   ??  работает только со значениями null и undefined; **возвращает первое правдивое значение

userName ?? 'User'
   null             => 'User'
	undefined        => 'User'
	0				     => userNume
	false,NaN, '';	  => userNume

******Оператор опциональной цепочки   (ES 11)*******************************************************************************************************
    
	?. - проверяет значение слево от себя
Оператор опциональной последовательности ( ?. ) предоставляет способ упростить доступ к значениям в цепочке объектов, когда возможно, 
что какое-то свойство (или метод) в ней равно undefined или null. 


let nestedProp = obj.first?.second; =>
Если значение obj.first равно null или undefined, выполнение выражения автоматически прекращается и возвращается undefined.

То есть он не прекращает действие кода, которое идет после этого выражения, а прото возвращает undefined


****** Map (карты)*******************************************************************************************************

https://learn.javascript.ru/map-set

Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
Map - это массив с массивами 

Отличие от объекта:
- Ключи могут быть чем угодно: массивом, обьектом, числом, строкой, функции и тп
- Порядок свойств такой, в котором добавляли
- При создании пустой катры в ней ничего не будет содержаться(никаких наследуемых свойств)
- Карты легко перебирать(4 способа)
- Размер легко получить через .size()


1) new Map() – создаёт коллекцию.

2) map.set(key, value) – записывает по ключу key значение value.

3) map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.

4) map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.

5) map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.

6) map.clear() – очищает коллекцию от всех элементов.

7) map.size – возвращает текущее количество элементов.

______Перебор_________ :

for ... of
.forEach()
+++++++++++++++++++++++++++ ->

8) map.keys() – возвращет итерируемый обьект по ключам

8) map.values() – возвращет итерируемый обьект по значениям

8) map.entries() – возвращет массив с массивами [[ключ, значение], [], []]

9) 


****** Set - массивоподобные объект (особый вид коллекции, где значение встречается только 1 раз)  *****************************************************

Set - это особый вид коллекции, где значение встречается только 1 раз


1) set.dalete(value) - удаляем значение

2) set.has(value) - возвращает true, если значение присутствует в коллекции, иначе false.

3) set.clear() - чистим set

4) set.size - получаем размер 

5) set.values() – возвращет итерируемый обьект по значениям = set.keys()
   ||
6) set.keys() – возвращет итерируемый обьект по ключам

7) set.entries() – возвращет массив с массивами [[ключ, ключ], [], []]

8) 

9) 



|||||||||||||||| ______________JS В РАБОТЕ_________________ |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
------------------------------------------------------------------------------------------------------------------------------------------


 ****** Event target  *******************************************************************************************************

1) event.target - событие на котором произошло событие 

2) event.target.tagName = 'BUTTON' - получаем тэг элемента на котором произошло событие 

3) event.target.remove - удаляем элемент на котором произошло событие 

4) event.target.id = '' - - получаем id элемента, на котором произошло событие 

5) event.target.textContent - получаем текст элемента, на котором произошло событие 

6) event.target.classList - получаем список классов элемента, на котором произошло событие 

7) event.clientX/clientY - получаем координаты куда тыкнули по Х/У 

8) event.target.value - получаем значение элемента, на котором произошло событие 

9) event.target.options.selectedIndex - получаем индекс эелмента, на ктором произошло событие

10) event.target.  - 

11) event.target.  -  

12) event.target.  - 



 ****** !!!!!   ДЕЛЕГИРОВАНИЕ   *******************************************************************************************************

https://learn.javascript.ru/event-delegation

Вешаем слушатель события не на каждый элемент, а на их родителя.

С помощью event.target.tagName = 'BUTTON' получаем элемент, на котором произошло событие


*******************  Classlist   *******************************************************************************************************

element.classList - получаем свойства элементов
1)	 	 .classList.length - получаем количество свойств 
2)	 	 .classList.item(0) - получаем первый класс элемента
3)		 .classList.add('red', 'blue') - добавляем класс red , blue
4)		 .classList.remove('red') - удаляем класс red
5)		 .classList.toggle('red') - если классred есть у элемента, то удаляем его, если нету то добавляет класс red
6)		 .classList.conta ('red') - если есть данный класс у элемента, возвращает TRUE , если нету - FALSE

****** Скрипты и время их выполнения  *******************************************************************************************************

https://learn.javascript.ru/js-animation

1) const timerId = setTimeout (function() { // Вызовится функция 1 раз через 2 секунды
	console.log('Hi');
}, 2000)

// Можно вызывать рекурсию внутри функции и лучше использовать его, т.к. 
он ждет 2 секунды и потом запускает код, в не зависимости от того, сколько выполняется код , он все равно ждет 2 секунды

** let timerId = setTimeout (function foo() { // Вызовится функция 1 раз через 2 секунды
		console.log('Hi');
		timerId = setTimeout(foo, 2000)
}, 2000)

2) clearInterval(timerId); - удалили таймер timerId

3) const timerId = setInterval (function() { // Вызывается функция через каждые 2 секунды
	console.log('Hi');
}, 2000)


****** Работа с датами  *******************************************************************************************************
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date
https://learn.javascript.ru/date

1) const date = new Date(); - дата и время берутся из системы

***Методы**  (Можем получать UTC данные - getUTC...)

2) date.getFullYear(); - получаем год

3) date.getMonth(); - получаем месяц

4) date.getDate(); - получаем дату(воскресенье - это 0, суббота - это 6)

5) date.getDay(); - получаем номер дня недели (воскресенье - это 0 день, суббота - это 6 день)

6) date.getTimezoneOffset(); - получаем разницу между часовыми поясамиUTC и нашим в минутах

7)date.getTime(); - получаем количество миллисекунд с 1 января 1970 года

*******ИСПОЛЬЗУЯ ВМЕСТО get - set , САМИ ЗАДАЕМ ДАННЫЕ******

8) date.pase(); - возвращает количество миллисекунд прошедших с 1 января 1970 года

9) 

10) 

11) 


****** Параметры документа , окно и работа с ними *******************************************************************************************************
document - 

window  - окно

scrin - экран, весь видимый монитор

1) Class.clientWidth - ширина с внешними паддингами , но без марджина и без скрола(15 px)

2) Class.clientHeight - высота с внешними паддингами , но без марджина и без скрола(15 px)


****** Функции - кострукторы *******************************************************************************************************
https://learn.javascript.ru/constructor-new

function User (name, id){
	this.name = name;
	this.id = id;
	this.human = true;
}

const ivan = new User('Ivan', 20); // Получаем обьект {name:'Ivan', id:20 , human: true }

****** Контекст вызова this ******

https://tproger.ru/translations/javascript-this-keyword/

1) Просто вызов обычной функции : this = window, но если есть 'use strict' , то undefined

2) Контекст у методов объекта - сам объект  

3) Функция конструктор (new): this в конструкторах и классах - это новый экземпляр объекта

4) Ручная привязка this: call(принимает аргументы в виде строки), apply(принимает аргументы в виде массива), 
		bind(возвращает новую функцию) func.bind(тут пишем чем будет this в новой функции)


- Когда в обработчике событий (addEventListener) прописана обычная функция, а не стрелочная this возвращает контекст 
элемент на котором произошел вызов this = event.target
 
- Когда в обработчике событий (addEventListener) стрелочная функция this возвращает контекст родителя( нет своего контекста) элемента на котором произошел вызов


****** Классы (синтаксический сахар) (ES6) *******************************************************************************************************

class Rectangle {
	constructor(height, width){
		this.height = height;
		this.width = width;
	}

	calcArea(){
		return this.height * this.width;
	}
}

const square = new Rectangle(1пишем то, что передаем в конструктор);
___________________________________________________________________________________________

class ColorRectangleText extends Rectangle { // ColorRectangle наследует свойства и методы у Rectangle
	constructor(height, width, color, text){
		super(height, width); // Вызываем тоже самое что было у родителя (строка 435-436) Должна быть всегда на первом месте 
		this.text = text;
		this.color = color;
	}
}

const div = new Rectangle(10, 20, 'red', 'Hello World' );


****** REST  Остаточные параметры *******************************************************************************************************

function sum(a, b, ...rest){ // ...rest - объединяет все оставшиеся аргументы в массив
console.log(a*b )
}
sum(5,2, 4);


 

|||||||||||||||| ______________Продвинутый JS_________________ |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
------------------------------------------------------------------------------------------------------------------------------------------

****** JSON *******************************************************************************************************

JSON.stringify(obj) - преобразует объект в нужный формат для сервера (т.е. все через двойные ковычки)
JSON.parse() - преобразует данные с сервера в обычные данные 


****** AJAX и общение с сервером *******************************************************************************************************

XMLHttpRequest - устаревшее обозначение

***** Методы XMLHttpRequest **** 

const request = new XMLHttpRequest();

1) request.open(method,url, login, pass); - собирает настройки которые помогут сделать запрос

- method - метода запроса ('GET' - получаем с сервера, 'POST' - отправляем на сервер 
- url - путь к нашему серверу 'js/current.json'
- async - отвечает за асинхронность ()
- login, pass - логин и пароль, если можем делать запросы только с ними

2) request.setRequestHeader('Content-type', 'application/json; charset=utf-8') - говорим серверу какие данные он получает !!!! Для formData() - не нужно !!!!!

3) request.send(body) - отправляем запрос (body - данные которые уходят на сервер, только в методе 'POST', в 'GET' body не будет )

_____________________________________________________
****** Свойства XMLHttpRequest ***** 

4) status - код статуса ( 2хх - успешно, 4хх - ошибка клиента )

5) statusText - текст статуса

6) response - ответ от сервера

7) redyState - состояние запроса (0 - объект создан; 1 - вызван метод open(); 2 - вызван метод send(), доступны заголовки и статус; 3 - загрузка(содержит частичные данные); 4  - операция завершена)


_____________________________________________________
****** События XMLHttpRequest ***** 

8) request.addEventListener('readystatechange', ...) - отслеживает статус готовности нашего запроса

9) request.addEventListener('load', ...) - сработывает, когда запрос полностью загрузился и получаем результат

10)



****** Promise (промисы) *******************************************************************************************************

https://disk.yandex.ru/d/HRKD_ia7eVkqrQ

const primise = new Promise(function(resolve, reject){
	// код
	resolve(somebody);
})

resolve -  если работа завершилась успешно
reject - если произошла ошибка

1) primise.then( (somebody) => {
	console.log(somebody)
} ).then(()=>{}) - обрабатывает положительный результат; Можно много последовательных действий и так далее, можно много раз

2) primise.catch( (somebody) =>{}) - Метод работает только в случае отклонения промиса, если что то пошло не так или ошибка ( если сработал reject()).

3) primise.finally( (somebody) =>{}) - Финальный, самый последний код, выполняется при любом исходе промиса. 

,

***** Методы Promise **** 

1) Promise.all([primise(x,y), primise(x,y)]).then(()=>{}) - служит для того, чтобы убедиться, что все промисы уже выполнены

2) Promise.race([primise(x,y), primise(x,y)]).then(()=>{}) - выполненный или отклонённый промис, в зависимости от того, с каким результатом завершится первый из переданных промисов



****** Fetch API (вместо XMLHttpRequest)  *******************************************************************************************************

Основан на промисах, поэтомы применяется .then() и тп.

let response = await fetch(url);

1) fetch('url').then(response => response.json) - 1) обращаемся к url (get запрос) 2) преобразуем json данные в JS обьект (встроенные метод fetch)
      1     |           2

2) fetch('url', { // обьект нужен только в POST запросах, в GET он не нужен
	method: 'POST',
	body: JSON.stringify(data),
	headers: {
		'Content-type': application/json
	}
}).then(response => response.json) 

3) fetch(url).ok - возвращает TRUE, если статус от 200 до 299, иначе возвращает FALSE

4) response.text() – читает ответ и возвращает как обычный текст,

5) response.json() – преобразуем JS обьект в данные json

6) response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),

7) response.blob() – возвращает объект как Blob (бинарные данные с типом),

8) response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных)




****** Lokal Storage (локальная БД)  *******************************************************************************************************

Находится в Application -> Lokal Storage

Максимальный объем 5 Мб

Чтобы записать в value объект - его нужно перевести в формат JSON (JSON.stringify(obj))

1) localStorage.setItem('key', 'value') - записываем значение в localStorage
								key - ключ. value - значение

2) localStorage.getItem('key') - получаем значение ключа из localStorage

3) localStorage.removeItem('key') - удаляем ключ из localStorage

4) localStorage.clear() - очищаем локальное хранилище




****** Регулярное выражение *******************************************************************************************************

https://learn.javascript.ru/regular-expressions

Состоит из паттерна и флагов.

new RegExp('pattern', 'flags'); - этим синтаксисом практически не пользуются 
				pattern - шаблон того, что ищем. 
				
 
**  /pattern/flag - чаще используют так 

1)** str.match(/n/ig) - ищем в строке все значения n, вне зависимости от регистра (пример)

2)** str.match(/\w\d\w\d/ig) - вернет значения вне зависимости от регистра, которые идут как: слово\цифра\слово\цифра ( это классы)

3)** str.match(\)


------------ pattern: ------------------ ( вернет первую, если нет флага g)

1) . - берем все значения(как в css - *)

2) \. - ищет точку

3) \\ - ищем палку \

4) \d - (diggets) ищем цифры   (\D - не числа)

5) \w - (worlds) ищем буквы    (\W - не буквы)

6) \s - (spases) ищем пробелы  (\S - не пробелы)

7) / /.. - ищем пробелы

------------ flag: ------------------

1) i - хотим найти вне зависимости от регистра

2) g - пытаемся найти сразу несколько

3) m - многострочный режим

4) 



------------ Методы: ------------------

1) .test() - если есть в регулярном выражении pattern, то вернет true, иначе false

2) 

3) 


****** Get Set ( геттеры и сеттеры)( свойства обьектов) *******************************************************************************************************

get - позволяют получать свойства обьекта

set - позволяют записывать свойства обьекта

let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
   	return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
   	[this.name, this.surname] = value.split(" ");
  }
};


*********** Модули *******************************************************************************************************











1) 

2) 

3) 

4) 

5) 

6) 

7) 

8) 

9) 

10) 

11) 

12) 

13) 

14) 

15) 

16) 

17) 

18) 

19) 

20) 

21) 